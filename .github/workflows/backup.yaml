name: Repository Backup

on:
  schedule:
    - cron: '0 0 * * *'  # Runs at 00:00 UTC daily
  workflow_dispatch:
    description: 'Manually trigger repository backup'
    inputs:
      reason:
        description: 'Reason for manual backup'
        required: true
        type: string
      force:
        description: 'Force backup even if no changes'
        required: false
        type: boolean
        default: false

jobs:
  backup:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history

      - name: Set up timestamp and variables
        run: |
          echo "TIMESTAMP=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_ENV
          echo "LAST_COMMIT=$(git rev-parse HEAD)" >> $GITHUB_ENV
          REPO_NAME=$(echo "${{ github.repository }}" | cut -d'/' -f2)
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV

      - name: Install B2 CLI
        run: pip install b2

      - name: Configure B2
        run: |
          b2 account authorize "${{ secrets.BACKUP_B2_KEY_ID }}" "${{ secrets.BACKUP_B2_APPLICATION_KEY }}"

      - name: Check last backup
        id: check
        continue-on-error: true
        run: |
          # Try to download the last commit hash file
          b2 file download \
            "b2://${{ secrets.BACKUP_B2_BUCKET_NAME }}/backups/${{ github.repository_owner }}/${{ env.REPO_NAME }}/last_commit.txt" \
            last_commit.txt || true
          
          if [ -f last_commit.txt ]; then
            LAST_BACKUP_COMMIT=$(cat last_commit.txt)
            echo "LAST_BACKUP_COMMIT=$LAST_BACKUP_COMMIT" >> $GITHUB_ENV
            
            if [ "${{ env.LAST_COMMIT }}" = "$LAST_BACKUP_COMMIT" ] && [ "${{ github.event.inputs.force }}" != "true" ]; then
              echo "No changes since last backup, skipping..."
              echo "skip=true" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi
          
          echo "skip=false" >> $GITHUB_OUTPUT

      - name: Create backup archive
        if: steps.check.outputs.skip != 'true'
        run: |
          zip -r "repo-backup-${{ env.TIMESTAMP }}.zip" .

      - name: Import GPG public key and encrypt
        if: steps.check.outputs.skip != 'true'
        run: |
          echo "${{ secrets.BACKUP_B2_GPG_PUBLIC_KEY }}" | gpg --batch --import
          KEYID=$(gpg --list-keys --with-colons | awk -F: '/^pub:/ { print $5 }')
          gpg --batch --yes --trust-model always \
              --recipient "$KEYID" \
              --encrypt "repo-backup-${{ env.TIMESTAMP }}.zip"

      - name: Upload to B2
        if: steps.check.outputs.skip != 'true'
        run: |
          # Upload the backup
          b2 file upload \
            --info src_last_modified_millis="$(date +%s000)" \
            "${{ secrets.BACKUP_B2_BUCKET_NAME }}" \
            "repo-backup-${{ env.TIMESTAMP }}.zip.gpg" \
            "backups/${{ github.repository_owner }}/${{ env.REPO_NAME }}/${{ env.TIMESTAMP }}.zip.gpg"
          
          # Update the last commit hash file
          echo "${{ env.LAST_COMMIT }}" > last_commit.txt
          b2 file upload \
            "${{ secrets.BACKUP_B2_BUCKET_NAME }}" \
            "last_commit.txt" \
            "backups/${{ github.repository_owner }}/${{ env.REPO_NAME }}/last_commit.txt"

      - name: Cleanup
        if: steps.check.outputs.skip != 'true'
        run: |
          rm -f repo-backup-${{ env.TIMESTAMP }}.zip
          rm -f repo-backup-${{ env.TIMESTAMP }}.zip.gpg
          rm -f last_commit.txt
